# 上板说明

## 背景

为遵循比赛需求，starry需要读取外部测例镜像。但由于SD卡镜像读取驱动较为复杂，因此比赛中默认将已有的SD卡镜像通过网络传输的方式传递到实际板子的`0x90000000`物理地址处。因此对Starry文件系统定义做出一些特定修改。



## 条件编译说明

引入`test`feature作为本地测试依据。若`feature img`打开，说明此时在qemu本地机器上运行，此时需要手动插入sdcard.img到内存中。否则在内核启动时，测例镜像已经被传递到对应地址0x90000000处。



## 本地插入镜像方式

### 本地获取镜像方式

执行如下指令：

```shell
$ ./build_img.sh judge
```

即可在根目录下获得sdcard.img。

### 本地插入镜像方式

通过`axdriver/build.rs`实现手动插入`sdcard.img`并且获取其具体位置。

在每一次生成内核镜像时都会手动插入这个测例镜像。

## 使用驱动说明

当前Starry使用ramdisk作为默认的文件系统驱动，相关定义在`axdriver/src/lib.rs:157`，具体代码如下：

```rust
use axconfig::{PHYS_VIRT_OFFSET, TESTCASE_MEMORY_SIZE, TESTCASE_MEMORY_START};
let mut ram_disk = driver_block::ramdisk::RamDisk::new(TESTCASE_MEMORY_SIZE);
ram_disk.copy_from_slice((TESTCASE_MEMORY_START + PHYS_VIRT_OFFSET) as *const u8);
all_devs.add_device(AxDeviceEnum::Block(ram_disk));
```



ramdisk指向了`[0x90000000,0x92000000)`地址，因此需要保证访问该地址时可以正确获取到实际文件镜像中的内容。因此需要对页表映射做出一些修改，具体代码在`axruntime/src:255`左右，具体代码如下：

```rust
// 插入文件系统的镜像映射
use axconfig::{TESTCASE_MEMORY_SIZE, TESTCASE_MEMORY_START};
use axhal::mem::{virt_to_phys, MemRegionFlags};
extern "C" {
    fn img_start();
}
#[cfg(feature = "img")]
// 此时qemu运行，文件镜像的位置需要由汇编确定
let img_start:PhysAddr = virt_to_phys((img_start as usize).into());

#[cfg(not(feature = "img"))]
// 此时上板运行，文件镜像的位置固定
let img_start:PhysAddr = TESTCASE_MEMORY_START.into();

kernel_page_table.map_region(
    phys_to_virt(TESTCASE_MEMORY_START.into()),
    img_start,
    TESTCASE_MEMORY_SIZE,
    MemRegionFlags::from_bits(1 << 0 | 1 << 1 | 1 << 4).unwrap().into(),
    true,
).unwrap();
```



## 上板流程

依据在线评测平台给出的上板指令，对测例镜像的拷贝如下：

```shell
$ bootp 0x80300000 sdcard.img.gz
ethernet@10090000: PHY present at 0
ethernet@10090000: Starting autonegotiation...
ethernet@10090000: Autonegotiation complete
ethernet@10090000: link up, 1000Mbps full-duplex (lpa: 0x2800)
BOOTP broadcast 1
BOOTP broadcast 2
BOOTP broadcast 3
DHCP client bound to address 192.168.100.50 (831 ms)
Using ethernet@10090000 device
TFTP from server 192.168.100.1; our IP address is 192.168.100.50
Filename 'sdcard.img.gz'.
Load address: 0x80300000
Loading: *#################################################################
#################################################################
#################################################################
#################################################################
###################################
17.7 MiB/s
done
Bytes transferred = 4317330 (41e092 hex) 
$ unzip 0x80300000 0x90000000 0x40000000
Uncompressed size: 64274432 = 0x3D4C000
$ mmc write 0x90000000 0 8192

MMC write: dev # 0, block # 0, count 33170 ... 33170 blocks written: OK
$ ls mmc 0
112544 arithoh
bin/
...

63 file(s), 1 dir(s)

$ bootp 0x80200000 u1.bin
...

$ go 0x80200000
```

查看得知应当是先将测例压缩包拷贝至0x80300000处，之后解压到0x90000000处。再将内核镜像拷贝到0x80200000处，并执行go语句开始运行。



**给出的测例镜像大小为61MB，而ramdisk的大小当前设置为0x400_0000，不确定是否会出现溢出。至少本地测试还没有问题。**



测例镜像下载地址：https://github.com/oscomp/testsuits-for-oskernel/releases/download/2023-final/sdcard.img.gz



## 本地上板指令

```shell
$ tftp 0x9000000 sdcard img;
$ tftp 0x8020000 sdcard os.bin;
$ go 0x80200000
```

